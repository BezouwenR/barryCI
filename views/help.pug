include ./head.pug

.container

  .row.mb-5
    .col(align='center')
      img(src='/public/barryci.svg')

  .row
    .col
      .jumbotron
        .display-4 Setup file
        p 
          | Each repo can optionally have a 
          code barryci.json
          |  file in the root which will define what happens when build or release happens. 
          | This file contains one large JSON object, with smaller settings. There are two main attributes:

        ul
          li
            code test
            span  contains an array of objects which define the commands to run for the build.
            pre
              | "build": [{"command": string, "args": string[]}, {"command": string, "args": string[]}]

          li
            code build
            span  is an object with what command to run for the unit tests to execute. If this attribute is provided, it will run after a successful build. 
            b This attribute is optional but is required to run tests.
            pre
              | "test": {"command": string, "args": string[]}

          li
            code release
            span  contains more attributes to determine what happens when a release is made. 
            b This attribute is optional but is required to create releases.

            ul
              li
                code do_build
                span  determines whether to build before making a release. This attribute is optional and the default is 
                code true
                spawn.
                pre "do_build": true
              li
                code post_commands
                span  is an array of objects which will run after the build and before the upload. This attribute is optional.
                pre
                  | "post_commands": [{"command": string, "args": string[]}, {"command": string, "args": string[]}]
              li
                code upload_file
                span  is the relative path to the file which will be uploaded (usually generated by the build or commands after the build.) 
                b This attribute is required for a the release to upload.
                pre "upload_file": "./release/release.savf"

        h4 Example
        .alert.alert-secondary
          pre.           
            {
              "build": [{
                "command": "gmake",
                "args": ["BIN_LIB=ILEUSION"]
              }],
              "test": {
                "command": "gmake",
                "args": ["tests"]
              },
              "release": {
                "post_commands": [{
                  "command": "gmake",
                  "args": ["release", "BIN_LIB=ILEUSION"]
                }],
                "upload_file": "./release/release.savf"
              }
            }

  .row
    .col
      .jumbotron
        .display-4 Unit tests
        p 
          span barryci can integrate unit test results right into results page. For barryci to understand a unit test result, the standard out from the program call (defined in the 
          code test
          span  attribute) must match a certain format. In barryci, tests will always run after a successful build.

        p
          span barryci can understand two different lines in the standard out.

        table(class='table table-condensed')
          tr
            td: code s:program.c
            td indicates that 'program.c' was successful.
          tr
            td: code f:program.c
            td indicates that 'program.c' has failed.

        p
          span You can define the test command to run in your 
          code barryci.json
          span  file.
        
        p 
          span It is possible to achieve this in a 
          code makefile
          span .

        .alert.alert-secondary
          pre.
            tests: json1.test json2.test json3.test
              @echo "Ran tests!"
            
            %.test:
              -system -si "CRTRPGMOD MODULE($(BIN_LIB)/$*) SRCSTMF('test/$*.rpgle') DBGVIEW($(DBGVIEW))"
              -system -si "CRTPGM PGM($(BIN_LIB)/$*) BNDDIR($(BIN_LIB)/NOXDB)"
              -system "call $(BIN_LIB)/$*" && echo "s:$*.rpgle" || { echo "f:$*.rpgle"; exit 1; }

        p Programs are simply ran. If the program crashes it fails, others is successful.

  .row
    .col
      .jumbotron
        .display-4 Release file
        p 
          span After a successful build (and test), barryci can upload a release file (like a savefile) to the GitHub repository. 
          span You can define the commands to run and what file to upload in your 
          code barryci.json
          span  file.

        p 
          span It is possible to achieve this in a 
          code makefile
          span .

        .alert.alert-secondary
          pre.
            release:
              @echo " -- Creating release. --"
              @echo " -- Creating save file. --"
              system "CRTSAVF FILE($(BIN_LIB)/RELEASE)"
              system "SAVLIB LIB($(BIN_LIB)) DEV(*SAVF) SAVF($(BIN_LIB)/RELEASE) OMITOBJ((RELEASE *FILE))"
              -rm -r release
              -mkdir release
              system "CPYTOSTMF FROMMBR('/QSYS.lib/$(BIN_LIB).lib/RELEASE.FILE') TOSTMF('./release/release.savf') STMFOPT(*REPLACE) STMFCCSID(1252) CVTDTA(*NONE)"
              @echo " -- Cleaning up... --"
              system "DLTOBJ OBJ($(BIN_LIB)/RELEASE) OBJTYPE(*FILE)"
              @echo " -- Release created! --"
              @echo ""
              @echo "To install the release, run:"
              @echo "  > CRTLIB $(BIN_LIB)"
              @echo "  > CPYFRMSTMF FROMSTMF('./release/release.savf') TOMBR('/QSYS.lib/$(BIN_LIB).lib/RELEASE.FILE') MBROPT(*REPLACE) CVTDTA(*NONE)"
              @echo "  > RSTLIB SAVLIB($(BIN_LIB)) DEV(*SAVF) SAVF($(BIN_LIB)/RELEASE)"
              @echo ""

  .row
    .col
      .jumbotron
        .display-4 Handling table changes
        p
          span Db2 for i provides the 
          code ON REPLACE
          span  syntax, which allows for table columns to be updated without the loss of data and without maintaining alter statements. This information can be found on the 
          a(href='https://www.ibm.com/support/knowledgecenter/en/ssw_ibm_i_73/sqlp/rbafyreplacetable.htm') Db2 for i wiki
          span .

        p
          span Using CREATE OR REPLACE TABLE lets you consolidate the master definition of a table into one statement. You do not need to maintain the source for the original CREATE TABLE statement plus a complex list of ALTER TABLE statements needed to recreate the most current version of a table. This CREATE TABLE statement can be executed to deploy the current definition of the table either as a new table or to replace a prior version of the table.
          span There are options to either keep the existing data in the table or to clear the data from the table during the replace. The default is to keep all data. If you elect to clear all the data, your new table definition does not need to be compatible with the original version. 
        p
          b In all cases
          span , other objects that depend on the table, such as referential constraints, triggers, and views, must remain satisfied 
          b or the replace will fail.

        p Suppose your original table was this basic INVENTORY table in an initial build.

        .alert.alert-primary
          pre.
            CREATE TABLE BIN_LIB/INVENTORY 
              (PARTNO   SMALLINT NOT NULL,
              DESCR    VARCHAR(24),
              QONHAND  INT,
              PRIMARY KEY(PARTNO))
        
        p Perhaps over time, you have updated the column names to be more descriptive, changed the DESCR column to be a longer Unicode column, and added a timestamp column for when the row was last updated. The following statement reflects all of these changes and can be executed against any prior version of the table, as long as the column names can be matched to the prior column names and the data types are compatible.

        p Also consider that if you commit this, your build system (e.g. GNU Make) will run the statement, update the table and retain the data.

        .alert.alert-primary
          pre.
            CREATE OR REPLACE TABLE BIN_LIB/INVENTORY 
              (PART_NUMBER FOR PARTNO        SMALLINT NOT NULL,
              DESCRIPTION FOR DESCR         VARGRAPHIC(500) CCSID 1200,
              QUANTITY_ON_HAND FOR QONHAND  INT,
              LAST_MODIFIED FOR MODIFIED    TIMESTAMP
                    NOT NULL GENERATED ALWAYS FOR EACH ROW ON UPDATE AS ROW CHANGE TIMESTAMP,
              PRIMARY KEY(PARTNO))

        p 
          span An example makefile which could implement this. We must replace a library variable with the library we are going to build in. We do this using 
          code sed
          span .

        .alert.alert-primary
          pre.
            BIN_LIB=DBTEST
            all: inventory.sql

            %.sql:
              sed "s/BIN_LIB/$(BIN_LIB)/g" ./$*.sql
              system "RUNSQLSTM SRCSTMF('./$*.sql') COMMIT(*NONE)"